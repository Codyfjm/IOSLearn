/*
 1.static与extern：修饰变量和函数
    1)static与extern修饰局部变量的效果
    2)static与extern修饰全局变量的效果
    3)static与extern修饰函数的效果
 
 2，static与extern修饰局部变量的效果
    1)如意局部变量呗static修饰，这个变量叫做静态变量
    2)静态变量不再存储在栈区域，而是存储在常量区中
    3)当函数执行完毕之后，这个静态变量不回被回收
      第一次执行这个函数的时候，就会将这个静态变量声明在常量区，函数执行完毕之后，这个静态变量
      不回被回收，后面再去执行的时候，声明静态变量这句话，就不会再执行了，而是直接跳过，直接使
      用这个静态变量的值
    4)static修饰的静态变量，函数结束不回被回收，函数无论执行多少次，这个静态变量只有1份
 
 3.extern 不能修饰局部变量
 
 4.全局变量
 
 1)先写全局变量的声明；
 2)再写全局变量的定义
 3)全局变量如果只有声明，没有定义，这个时候编译器回自动的实现这个全局变量，自动初始化为0
 
 5，当我们分模块开发的时候，如果要在模块中声明全局变量
    1)全局变量的声明药写在.h文件中
    2)全局变量的实现药写在.c文件中
    3)如果将全局变量定义在模块中，这个全局变量必须要使用static或者extern修饰
 
    如果定义在模块中的全局变量，使用extern修饰，这个模块中的全局变量就可以跨模块访问
    如果定义在模块中的全局变量，使用static修饰，这个模块中的全局变量就只能在当前模块中访问
 
 6,static和extern修饰函数
    1)如果函数被extern（默认）修饰，那么这个函数可以跨模块调用
    2)如果函数被static修饰，那么这个函数只能在当前模块中调用，无法跨模块调用
 修饰
 
 
 */

#include <stdio.h>

int num;//全局变量的声明
int num = 10;//全局变量的定义

void test(){

//    int num = 0;
//    num = 1
//    num = 1
//    num = 1
//    num = 1
//    num = 1
    
    static int num = 0;
//    num = 1
//    num = 2
//    num = 3
//    num = 4
//    num = 5
    num++;
    printf("num = %d\n",num);
}

int main(int argc, const char * argv[]) {
    test();
    test();
    test();
    test();
    test();
    
}
